---
title: "11 - El peso de los pescados"
---

El siguiente programa muestra como se puede resolver en R el ejercicio
**El peso de los pescados** de la Práctica 3.

```{r}
library(ggplot2)
library(ggdist)
library(dplyr)

url <- paste0(
  "https://raw.githubusercontent.com/estadisticaunr/",
  "estadistica-bayesiana/main/datos/fish-market-posterior.csv"
)

df_posterior <- readr::read_csv(url)
```


```{r}
#| warning: false
#| fig-width: 7
#| fig-align: center
#| fig-cap: Posterior del intercepto

# Posterior marginal: intercepto
ggplot(df_posterior) +
  geom_histogram(aes(x=intercepto))
```

```{r}
#| warning: false
#| fig-width: 7
#| fig-align: center
#| fig-cap: Posterior de la pendiente

# Posterior marginal: pendiente
ggplot(df_posterior) +
  geom_histogram(aes(x=pendiente))
```


```{r}
#| warning: false
#| fig-width: 7
#| fig-align: center
#| fig-cap: Posterior de una variable transformada

ggplot(df_posterior) +
  geom_histogram(aes(x=1.01^pendiente))
```

```{r}
#| warning: false
#| fig-width: 7
#| fig-align: center
#| fig-cap: Posterior del $\sigma$

# Posterior marginal: sigma
ggplot(df_posterior) +
  geom_histogram(aes(x=sigma))
```


```{r}
#| warning: false
#| fig-width: 7
#| fig-align: center
#| fig-cap: Posterior conjunto de la pendiente y el intercepto

# Posterior conjunto
ggplot(df_posterior) +
  geom_point(aes(x=intercepto, y=pendiente))
```


Consideremos un pescado de $L = 30\text{ cm}$.

$\mu$ depende de $\beta_0$ y $\beta_1$ y por lo tanto tiene una distribución _a posteriori_.

```{r}
#| fig-width: 7
#| fig-align: center
#| fig-cap: Distribución del peso promedio para un pescado de 30 cm.
Largo <- 30

df_posterior$log_Peso_30_prom <- df_posterior$intercepto + df_posterior$pendiente * log(Largo) # log peso medio promedio

df_posterior$Peso_30_prom <- exp(df_posterior$log_Peso_30_prom) # peso medio promedio

ggplot(df_posterior) +
  geom_histogram(aes(x=Peso_30_prom))
```

¿Cómo obtenemos la distribución predictiva _a posteriori_?

```{r}
#| fig-width: 7
#| fig-align: center
#| fig-cap: Distribución predictiva a posteriori.

df_posterior$log_Peso_30 <- rnorm(n = nrow(df_posterior), mean = df_posterior$log_Peso_30_prom, sd = df_posterior$sigma)

df_posterior$Peso_30 <- exp(df_posterior$log_Peso_30)

ggplot(df_posterior) +
  geom_histogram(aes(x=Peso_30))
```

¿Cómo graficamos la recta de regresión?

```{r}
log_largo <- seq(0,5,length.out=100)

calc_log_peso_prom <- function(x, posterior){
  return(posterior$intercepto + posterior$pendiente * x)
}

log_peso_prom <- sapply(log_largo, calc_log_peso_prom, df_posterior)

dim(log_peso_prom)
```


```{r}
#| fig-width: 7
#| fig-align: center
#| fig-cap: Algunas rectas de regresión posibles a posteriori

log_peso_prom_new <- 
  as.data.frame(t(log_peso_prom[200:299,])) |> # selecciono 100 muestras
  setNames(paste0("rep",1:100)) |> # renombro las columnas
  cbind(log_largo) |> # agrego el predictor
  tidyr::pivot_longer(cols = -log_largo, names_to = "rep", values_to = "value") # convierto a formato largo para graficar

ggplot(log_peso_prom_new) +
  geom_line(aes(x=log_largo, y=value, group=rep), alpha=0.3)
```


```{r}
#| fig-width: 7
#| fig-align: center
#| fig-cap: Recta (curva) de regresión en la escala original (probables a posteriori)

ggplot(log_peso_prom_new) +
  geom_line(aes(x=exp(log_largo), y=exp(value), group=rep), alpha=0.3)
```
```{r}
log_peso_prom_new_group <- 
log_peso_prom_new |>
  group_by(log_largo) |>
  summarise(q05 = quantile(value,0.05),
            mean = mean(value),
            q95 = quantile(value,0.95)) 
```


```{r}
#| fig-width: 7
#| fig-align: center
#| fig-cap: Recta (curva) de regresión con intervalo de credibilidad del 90%

log_peso_prom_new_group |>
  ggplot() +
  geom_ribbon(aes(x = log_largo, ymin = q05, ymax = q95), fill="gray50") +
  geom_line(aes(x = log_largo, y = mean))
```

```{r}
#| fig-width: 7
#| fig-align: center
#| fig-cap: Recta (curva) de regresión en la escala original con intervalo de credibilidad del 90%

log_peso_prom_new_group |>
  ggplot() +
  geom_ribbon(aes(x = exp(log_largo), ymin = exp(q05), ymax = exp(q95)), fill="gray50") +
  geom_line(aes(x = exp(log_largo), y = exp(mean)))
```

```{r}
#| fig-width: 7
#| fig-align: center
#| fig-cap: Recta de regresión con bandas/intervalos de credibilidad

log_peso_prom_new |>
  group_by(log_largo) |>
  mean_hdi(value, .width = c(.50, .70, .90),) |>
  ggplot(aes(x = log_largo, y = value, ymin = .lower, ymax = .upper)) +
  geom_lineribbon(size=.8) +
  scale_fill_brewer()
```

```{r}
#| fig-width: 7
#| fig-align: center
#| fig-cap: Recta (curva) de regresión en la escala original con bandas de credibilidad

log_peso_prom_new |>
  group_by(exp_log_largo = exp(log_largo)) |>
  mean_hdi(exp_value = exp(value), .width = c(.50, .70, .90),) |>
  ggplot(aes(x = exp_log_largo, y = exp_value, ymin = .lower, ymax = .upper)) +
  geom_lineribbon(size=.8) +
  scale_fill_brewer()
```

Mismos gráficos para la distribución predictiva _a posteriori_

```{r}
pred_log_peso <- function(x, posterior){
  return(rnorm(n = nrow(posterior), mean = posterior$intercepto + posterior$pendiente * x, sd = posterior$sigma))
}

log_peso <- sapply(log_largo, pred_log_peso, df_posterior)

log_peso_new <- 
  as.data.frame(t(log_peso[600:699,])) |> 
  setNames(paste0("rep",1:100)) |>
  cbind(log_largo) |>
  tidyr::pivot_longer(cols = -log_largo, names_to = "rep", values_to = "value")

log_peso_new_group <- 
  log_peso_new |>
  group_by(log_largo) |>
  summarise(q05 = quantile(value,0.05),
            mean = mean(value),
            q95 = quantile(value,0.95)) 
```

```{r}
#| fig-width: 7
#| fig-align: center
#| fig-cap: Recta (curva) de regresión en la escala original con bandas de credibilidad

log_peso_new_group |>
  ggplot() +
  geom_ribbon(aes(x = log_largo, ymin = q05, ymax = q95), fill="gray50") +
  geom_line(aes(x = log_largo, y = mean))
```
```{r}
#| fig-width: 7
#| fig-align: center
#| fig-cap: Recta (curva) de regresión en la escala original con bandas de credibilidad

log_peso_new_group |>
  ggplot() +
  geom_ribbon(aes(x = exp(log_largo), ymin = exp(q05), ymax = exp(q95)), fill="gray50") +
  geom_line(aes(x = exp(log_largo), y = exp(mean)))
```


